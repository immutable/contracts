// Copyright Immutable Pty Ltd 2018 - 2024
// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

// Signature Validation
import {SignatureChecker} from "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";

// Access Control
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";

// Reentrancy Guard
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";

// EIP-712 Typed Structs
import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";

/**
 *
 * @title GuardedMulticaller2 contract
 * @author Immutable
 * @notice This contract is used to batch calls to other contracts.
 * @dev This contract is not designed to be upgradeable. If an issue is found with this contract,
 *  a new version will be deployed. All approvals granted to this contract will be revoked before
 *  a new version is deployed. Approvals will be granted to the new contract.
 */
contract GuardedMulticaller2 is AccessControl, ReentrancyGuard, EIP712 {
    /// @dev Struct for call data
    struct Call {
        address target;
        string functionSignature;
        bytes data;
    }

    /// @dev Mapping of reference to executed status
    mapping(bytes32 ref => bool executed) private replayProtection;

    /// @dev Only those with MULTICALL_SIGNER_ROLE can generate valid signatures for execute function.
    bytes32 public constant MULTICALL_SIGNER_ROLE = bytes32("MULTICALL_SIGNER_ROLE");

    /// @dev EIP712 typehash for call
    bytes32 internal constant CALL_TYPEHASH = keccak256("Call(address target,string functionSignature,bytes data)");

    /// @dev EIP712 typehash for execute function
    bytes32 internal constant MULTICALL_TYPEHASH =
        keccak256(
            "Multicall(bytes32 ref,Call[] calls,uint256 deadline)Call(address target,string functionSignature,bytes data)"
        );

    /// @dev Event emitted when execute function is called
    event Multicalled(address indexed _multicallSigner, bytes32 indexed _reference, Call[] _calls, uint256 _deadline);

    /// @dev Error thrown when reference is invalid
    error InvalidReference(bytes32 _reference);

    /// @dev Error thrown when reference has already been executed
    error ReusedReference(bytes32 _reference);

    /// @dev Error thrown when deadline is expired
    error Expired(uint256 _deadline);

    /// @dev Error thrown when signer is not authorized
    error UnauthorizedSigner(address _multicallSigner);

    /// @dev Error thrown when signature is invalid
    error UnauthorizedSignature(bytes _signature);

    /// @dev Error thrown when call array is empty
    error EmptyCallArray();

    /// @dev Error thrown when call reverts
    error FailedCall(Call _call, bytes _returnData);

    /// @dev Error thrown when target address is not a contract
    error NonContractAddress(Call _call);

    /// @dev Error thrown when function signature is invalid
    error InvalidFunctionSignature(Call _call);

    /**
     *
     * @notice Grants DEFAULT_ADMIN_ROLE to the contract creator
     * @param _owner Owner of the contract
     * @param _name Name of the contract
     * @param _version Version of the contract
     */
    // solhint-disable-next-line no-unused-vars
    constructor(address _owner, string memory _name, string memory _version) EIP712(_name, _version) {
        _grantRole(DEFAULT_ADMIN_ROLE, _owner);
    }

    /**
     *
     * @notice Execute a list of calls. Returned data from calls are ignored.
     *  The signature must be generated by an address with MULTICALL_SIGNER_ROLE
     *  The signature must be valid
     *  The signature must not be expired
     *  The reference must be unique
     *  The reference must not be executed before
     *  The list of calls must not be empty
     *  The list of calls is executed in order
     *
     * @param _multicallSigner Address of an approved signer
     * @param _reference Reference
     * @param _calls List of calls
     * @param _deadline Expiration timestamp
     * @param _signature Signature of the multicall signer
     */
    // slither-disable-start low-level-calls,cyclomatic-complexity
    // solhint-disable-next-line code-complexity
    function execute(
        address _multicallSigner,
        bytes32 _reference,
        Call[] calldata _calls,
        uint256 _deadline,
        bytes calldata _signature
    ) external nonReentrant {
        // solhint-disable-next-line not-rely-on-time
        if (_deadline < block.timestamp) {
            revert Expired(_deadline);
        }
        if (_reference == 0) {
            revert InvalidReference(_reference);
        }
        if (replayProtection[_reference]) {
            revert ReusedReference(_reference);
        }
        if (_calls.length == 0) {
            revert EmptyCallArray();
        }
        for (uint256 i = 0; i < _calls.length; i++) {
            if (bytes(_calls[i].functionSignature).length == 0) {
                revert InvalidFunctionSignature(_calls[i]);
            }
            if (_calls[i].target.code.length == 0) {
                revert NonContractAddress(_calls[i]);
            }
        }
        if (!hasRole(MULTICALL_SIGNER_ROLE, _multicallSigner)) {
            revert UnauthorizedSigner(_multicallSigner);
        }

        // Signature validation
        if (
            !SignatureChecker.isValidSignatureNow(
                _multicallSigner,
                _hashTypedData(_reference, _calls, _deadline),
                _signature
            )
        ) {
            revert UnauthorizedSignature(_signature);
        }

        replayProtection[_reference] = true;

        // Multicall
        for (uint256 i = 0; i < _calls.length; i++) {
            bytes4 functionSelector = bytes4(keccak256(bytes(_calls[i].functionSignature)));
            bytes memory callData = abi.encodePacked(functionSelector, _calls[i].data);
            // solhint-disable avoid-low-level-calls
            // slither-disable-next-line calls-loop
            (bool success, bytes memory returnData) = _calls[i].target.call(callData);
            if (!success) {
                // Look for revert reason and bubble it up if present
                if (returnData.length < 4) {
                    revert FailedCall(_calls[i], returnData);
                }
                // solhint-disable-next-line no-inline-assembly
                assembly {
                    // The easiest way to bubble the revert reason is using memory via assembly
                    revert(add(returnData, 32), mload(returnData))
                }
            }
        }

        emit Multicalled(_multicallSigner, _reference, _calls, _deadline);
    }

    // slither-disable-end low-level-calls,cyclomatic-complexity

    /**
     * @notice Grants MULTICALL_SIGNER_ROLE to a user. Only DEFAULT_ADMIN_ROLE can call this function.
     *
     * @param _user User to grant MULTICALL_SIGNER_ROLE to
     */
    function grantMulticallSignerRole(address _user) external onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(MULTICALL_SIGNER_ROLE, _user);
    }

    /**
     * @notice Revokes MULTICALL_SIGNER_ROLE for a user. Only DEFAULT_ADMIN_ROLE can call this function.
     *
     * @param _user User to grant MULTICALL_SIGNER_ROLE to
     */
    function revokeMulticallSignerRole(address _user) external onlyRole(DEFAULT_ADMIN_ROLE) {
        revokeRole(MULTICALL_SIGNER_ROLE, _user);
    }

    /**
     * @notice Gets whether the reference has been executed before.
     *
     * @param _reference Reference to check
     */
    function hasBeenExecuted(bytes32 _reference) external view returns (bool) {
        return replayProtection[_reference];
    }

    /**
     *
     * @dev Returns hash of array of calls
     *
     * @param _calls Array of calls
     */
    function _hashCallArray(Call[] calldata _calls) internal pure returns (bytes32) {
        bytes32[] memory hashedCallArr = new bytes32[](_calls.length);
        for (uint256 i = 0; i < _calls.length; i++) {
            hashedCallArr[i] = keccak256(
                abi.encode(CALL_TYPEHASH, _calls[i].target, _calls[i].functionSignature, _calls[i].data)
            );
        }
        return keccak256(abi.encode(hashedCallArr));
    }

    /**
     *
     * @dev Returns EIP712 message hash for given parameters
     *
     * @param _reference Reference
     * @param _calls List of calls
     * @param _deadline Expiration timestamp
     */
    function _hashTypedData(
        bytes32 _reference,
        Call[] calldata _calls,
        uint256 _deadline
    ) internal view returns (bytes32) {
        return
            _hashTypedDataV4(keccak256(abi.encode(MULTICALL_TYPEHASH, _reference, _hashCallArray(_calls), _deadline)));
    }
}
