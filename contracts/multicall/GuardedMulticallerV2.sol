// Copyright Immutable Pty Ltd 2018 - 2023
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

// Signature Validation
import {SignatureChecker} from "@openzeppelin/contracts/utils/cryptography/SignatureChecker.sol";

// Access Control
import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";

// Reentrancy Guard
import {ReentrancyGuard} from "@openzeppelin/contracts/security/ReentrancyGuard.sol";

// EIP-712 Typed Structs
import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";

/**
 *
 * @title GuardedMulticallerV2 contract
 * @author Immutable
 * @notice This contract is used to batch calls to other contracts.
 * @dev This contract is not designed to be upgradeable. If an issue is found with this contract,
 *  a new version will be deployed. All approvals granted to this contract will be revoked before
 *  a new version is deployed. Approvals will be granted to the new contract.
 */
contract GuardedMulticallerV2 is AccessControl, ReentrancyGuard, EIP712 {
    /// @dev Struct for call data
    struct Call {
        address target;
        string functionSignature;
        bytes data;
    }

    /// @dev Mapping of reference to executed status
    // solhint-disable-next-line named-parameters-mapping
    mapping(bytes32 => bool) private replayProtection;

    /// @dev Only those with MULTICALL_SIGNER_ROLE can generate valid signatures for execute function.
    bytes32 public constant MULTICALL_SIGNER_ROLE = bytes32("MULTICALL_SIGNER_ROLE");

    /// @dev EIP712 typehash for execute function
    bytes32 internal constant MULTICALL_TYPEHASH =
        keccak256("Multicall(bytes32 ref,address[] targets,bytes[] data,uint256 deadline)");

    /// @dev Event emitted when execute function is called
    event Multicalled(
        address indexed _multicallSigner,
        bytes32 indexed _reference,
        Call[] _calls,
        uint256 _deadline
    );

    /// @dev Error thrown when reference is invalid
    error InvalidReference(bytes32 _reference);

    /// @dev Error thrown when reference has already been executed
    error ReusedReference(bytes32 _reference);

    /// @dev Error thrown when call array is empty
    error EmptyCallArray();

    /// @dev Error thrown when address array and data array have different lengths
    error AddressDataArrayLengthsMismatch(uint256 _addressLength, uint256 _dataLength);

    /// @dev Error thrown when deadline is expired
    error Expired(uint256 _deadline);

    /// @dev Error thrown when target address is not a contract
    error NonContractAddress(Call _call);

    /// @dev Error thrown when signer is not authorized
    error UnauthorizedSigner(address _multicallSigner);

    /// @dev Error thrown when signature is invalid
    error UnauthorizedSignature(bytes _signature);

    /// @dev Error thrown when call reverts
    error FailedCall(Call _call);

    /// @dev Error thrown when call data is invalid
    error InvalidCallData(address _target, bytes _data);

    /// @dev Error thrown when call data is unauthorized
    error UnauthorizedFunction(address _target, string _functionSignature);

    /**
     *
     * @notice Grants DEFAULT_ADMIN_ROLE to the contract creator
     * @param _owner Owner of the contract
     * @param _name Name of the contract
     * @param _version Version of the contract
     */
    // solhint-disable-next-line no-unused-vars
    constructor(address _owner, string memory _name, string memory _version) EIP712(_name, _version) {
        _grantRole(DEFAULT_ADMIN_ROLE, _owner);
    }

    /**
     *
     * @dev Returns hash of array of calls
     *
     * @param _calls Array of calls
     */
    function hashCallArray(Call[] calldata _calls) public pure returns (bytes32) {
        bytes32[] memory hashedCallArr = new bytes32[](_calls.length);
        for (uint256 i = 0; i < _calls.length; i++) {
            hashedCallArr[i] = keccak256(abi.encodePacked(_calls[i].target, _calls[i].functionSignature, _calls[i].data));
        }
        return keccak256(abi.encodePacked(hashedCallArr));
    }

    /**
     *
     * @notice Execute a list of calls. Returned data from calls are ignored.
     *  The signature must be generated by an address with EXECUTION_MULTICALL_SIGNER_ROLE
     *  The signature must be valid
     *  The signature must not be expired
     *  The reference must be unique
     *  The reference must not be executed before
     *  The list of calls must not be empty
     *  The list of calls is executed in order
     *
     * @param _multicallSigner Address of an approved signer
     * @param _reference Reference
     * @param _calls List of calls
     * @param _deadline Expiration timestamp
     * @param _signature Signature of the multicall signer
     */
    // slither-disable-start low-level-calls,cyclomatic-complexity
    // solhint-disable-next-line code-complexity
    function execute(
        address _multicallSigner,
        bytes32 _reference,
        Call[] calldata _calls,
        uint256 _deadline,
        bytes calldata _signature
    ) external nonReentrant {
        // solhint-disable-next-line not-rely-on-time
        if (_deadline < block.timestamp) {
            revert Expired(_deadline);
        }
        if (_reference == 0) {
            revert InvalidReference(_reference);
        }
        if (replayProtection[_reference]) {
            revert ReusedReference(_reference);
        }
        if (_calls.length == 0) {
            revert EmptyCallArray();
        }
        for (uint256 i = 0; i < _calls.length; i++) {
            if (_calls[i].target.code.length == 0) {
                revert NonContractAddress(_calls[i]);
            }
        }
        if (!hasRole(MULTICALL_SIGNER_ROLE, _multicallSigner)) {
            revert UnauthorizedSigner(_multicallSigner);
        }

        // Signature validation
        if (
            !SignatureChecker.isValidSignatureNow(
                _multicallSigner,
                _hashTypedData(_reference, _calls, _deadline),
                _signature
            )
        ) {
            revert UnauthorizedSignature(_signature);
        }

        replayProtection[_reference] = true;

        // Multicall
        for (uint256 i = 0; i < _calls.length; i++) {
            bytes4 functionSelector = bytes4(keccak256(bytes(_calls[i].functionSignature)));
            bytes memory callData = abi.encodePacked(functionSelector, _calls[i].data);
            // solhint-disable avoid-low-level-calls
            // slither-disable-next-line calls-loop
            (bool success, bytes memory returnData) = _calls[i].target.call(callData);
            if (!success) {
                if (returnData.length == 0) {
                    revert FailedCall(_calls[i]);
                }
                // solhint-disable-next-line no-inline-assembly
                assembly {
                    revert(add(returnData, 32), mload(returnData))
                }
            }
        }

        emit Multicalled(_multicallSigner, _reference, _calls, _deadline);
    }
    // slither-disable-end low-level-calls,cyclomatic-complexity

    /**
     * @notice Grants MULTICALL_SIGNER_ROLE to a user. Only DEFAULT_ADMIN_ROLE can call this function.
     *
     * @param _user User to grant MULTICALL_SIGNER_ROLE to
     */
    function grantMulticallSignerRole(address _user) external onlyRole(DEFAULT_ADMIN_ROLE) {
        grantRole(MULTICALL_SIGNER_ROLE, _user);
    }

    /**
     * @notice Revokes MULTICALL_SIGNER_ROLE for a user. Only DEFAULT_ADMIN_ROLE can call this function.
     *
     * @param _user User to grant MULTICALL_SIGNER_ROLE to
     */
    function revokeMulticallSignerRole(address _user) external onlyRole(DEFAULT_ADMIN_ROLE) {
        revokeRole(MULTICALL_SIGNER_ROLE, _user);
    }

    /**
     * @notice Gets whether the reference has been executed before.
     *
     * @param _reference Reference to check
     */
    function hasBeenExecuted(bytes32 _reference) external view returns (bool) {
        return replayProtection[_reference];
    }

    /**
     *
     * @dev Returns EIP712 message hash for given parameters
     *
     * @param _reference Reference
     * @param _calls List of calls 
     * @param _deadline Expiration timestamp
     */
    function _hashTypedData(
        bytes32 _reference,
        Call[] calldata _calls,
        uint256 _deadline
    ) internal view returns (bytes32) {
        return
            _hashTypedDataV4(
                keccak256(
                    abi.encode(
                        MULTICALL_TYPEHASH,
                        _reference,
                        hashCallArray(_calls),
                        _deadline
                    )
                )
            );
    }
}
